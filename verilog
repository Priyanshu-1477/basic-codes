Dataflow Model[1]
module comp_4bit (
input [3:0]a,b,
output ag,bg,eq
);
assign ag = (a[3] & ~b[3]) |
(~(a[3] ^ b[3]) & (a[2] & ~b[2])) |
(~(a[3] ^ b[3]) & (~(a[2] ^ b[2])) & (a[1] & ~b[1])) |
(~(a[3] ^ b[3]) & (~(a[2] ^ b[2])) & (~(a[1] ^ b[1])
& (a[0] & ~b[0]));
assign bg = (b[3] & ~a[3]) |
(~(b[3] ^ a[3]) & (b[2] & ~a[2])) |
(~(b[3] ^ a[3]) & (~(b[2] ^ a[2])) & (b[1] & ~a[1])) |
(~(b[3] ^ a[3]) & (~(b[2] ^ a[2])) & (~(b[1] ^ a[1]))
& (b[0] & a[0]));
assign eq = (~(b[3] ^ a[3])) & (~(b[2] ^ a[2])) & (~(b[1] ^ a[1]))
& (~(b[0] ^ a[0]));
endmodule





Behavioral Model[2]
module comp_4bit (
input [3:0] a,b,
output ag,bg,eq
);
assign ag = a>b;
assign bg = a<b;
assign eq = a==b;
endmodule
Test bench
module comp_4bit_tb;
reg [3:0]a,b;
wire ag,bg,eq;
comp_4bit uut (.a(a), .b(b), .ag(ag), .bg(bg),.eq(eq));
initial begin
a = 4'b1111; b = 4'b0; #10;
a = 4'b0; b = 4'b1111; #10;
a = 4'b0; b = 4'b0; #10;
$finish;
end
endmodule




module mux2to1 (
input [1:0]in, input sel,
output out
);
wire t1,t2,t3;
not N1 (t3,sel);
and A1 (t1,in[1],sel);
and A2 (t2,in[0],t3);
or OR1 (out,t2,t1);
endmodule
module mux4to1 (
input [3:0]in,
input [1:0]sel,
output out
);
wire [1:0]t;
mux2to1 M0 (in[3:2],sel[0],t[1]);
mux2to1 M1 (in[1:0],sel[0],t[0]);
mux2to1 M2 (t,sel[1],out);
endmodule
module mux8to1 (
input [7:0]in,
input [2:0]sel,
output out
);
wire [1:0]t;
mux4to1 M0 (in[7:4],sel[1:0],t[1]);
mux4to1 M1 (in[3:0],sel[1:0],t[0]);
mux2to1 M2 (t,sel[2],out);
endmodule